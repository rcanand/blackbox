c
exit
(1..1).to_a
(2..1).to_a
Range.new(2,0).to_a
Range.new(2,0)
(0..2).to_a
(2..0).to_a
(0..2).include?(1)
(2..0).include?(1)
column_range.include?(atom_column)
column_range
atom_column
row_range.include?(atom_row)
row_range
row_range.include?(atom_row) && column_range.include?(atom_column)
n
atom_positions
n
atom
s
n
s
n
[row1, column1, row2, column2]
n
square2
square1
square1, square2
n
s
n
s
n
s
quit
@atoms.each
@atoms
n
column_range
n
row_range
n
column2
row2
n
column1
row1
n
@atoms
n
square2
square1
n
s
any_atom_between?(edge_square, facing_edge_square)
n
 get_facing_edge_square(edge_square)
n
@atoms
s
hit?(edge_square)
n
s
c
n
exp == act
n
act
exp
msg
n
any_atom_between?(edge_square, facing_edge_square)
n
get_facing_edge_square(edge_square)
edge_square
n
@atoms
edge_square?(edge_square)
s
n
pass_through?(edge_square)
pass_through?(edge_square))
n
s
exit
@num_atoms == 0
s
@num_atoms
n
s
exit
c
where
exit
where
help
@num_atoms
n
c
n
@num_atoms
edge_square?(edge_square)
c
disp edge_square
c
edge_square
exit
self.dimension
@dimension
@outer_dimension
column
n
column
row
s
